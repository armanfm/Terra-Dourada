<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Terra Dourada ‚Äî Painel Completo</title>

<script src="https://cdn.jsdelivr.net/npm/pouchdb@7.3.1/dist/pouchdb.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>

<style>
body {
  background: #0a0f0a;
  color: #d4af37;
  font-family: system-ui;
  padding: 20px;
  margin: 0;
}

h1 {
  color: #ffd700;
  text-align: center;
  margin-bottom: 10px;
}

.subtitle {
  text-align: center;
  opacity: 0.8;
  margin-bottom: 30px;
}

/* Abas */
.tabs {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-bottom: 30px;
  flex-wrap: wrap;
}

.tab-btn {
  background: transparent;
  border: 1px solid #d4af37;
  padding: 12px 20px;
  color: #d4af37;
  border-radius: 10px;
  cursor: pointer;
  transition: 0.3s;
  font-size: 14px;
}

.tab-btn.active {
  background: rgba(212,175,55,0.2);
  border-color: #ffd700;
}

.tab-btn:hover {
  background: rgba(212,175,55,0.15);
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

/* Dashboard */
.controls {
  display: flex;
  justify-content: center;
  gap: 15px;
  flex-wrap: wrap;
  margin-bottom: 30px;
}

button {
  background: transparent;
  border: 1px solid #d4af37;
  padding: 12px 20px;
  color: #d4af37;
  border-radius: 10px;
  cursor: pointer;
  transition: 0.3s;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

button:hover {
  background: rgba(212,175,55,0.15);
  transform: translateY(-2px);
}

.dashboard {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 30px;
}

.stat-card {
  background: #1a1f1a;
  border: 1px solid rgba(212,175,55,0.3);
  border-radius: 15px;
  padding: 25px;
  text-align: center;
}

.stat-number {
  font-size: 3rem;
  font-weight: bold;
  margin: 10px 0;
}

.stat-pendente { color: #ffa500; }
.stat-enviado { color: #00ff00; }

.stat-label {
  font-size: 1.1rem;
  opacity: 0.8;
}

.votos-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.votos-list {
  background: #1a1f1a;
  border: 1px solid rgba(212,175,55,0.3);
  border-radius: 15px;
  padding: 20px;
  max-height: 400px;
  overflow-y: auto;
}

.votos-list h3 {
  margin-top: 0;
  color: #ffd700;
  border-bottom: 1px solid rgba(212,175,55,0.3);
  padding-bottom: 10px;
}

.voto-item {
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 15px;
  border-left: 4px solid;
}

.voto-pendente {
  border-left-color: #ffa500;
  background: rgba(255,165,0,0.1);
}

.voto-enviado {
  border-left-color: #00ff00;
  background: rgba(0,255,0,0.1);
}

.voto-candidato {
  font-weight: bold;
  font-size: 1.1rem;
  margin-bottom: 5px;
}

.voto-eleitor {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-bottom: 5px;
}

.voto-cid {
  font-family: monospace;
  font-size: 0.8rem;
  background: rgba(0,0,0,0.3);
  padding: 4px 8px;
  border-radius: 5px;
  word-break: break-all;
}

.voto-timestamp {
  font-size: 0.8rem;
  opacity: 0.7;
  margin-top: 8px;
}

.empty-state {
  text-align: center;
  padding: 40px;
  opacity: 0.6;
}

.empty-state i {
  font-size: 3rem;
  margin-bottom: 15px;
  display: block;
}

/* Logs */
#log {
  white-space: pre-wrap;
  background: #111;
  padding: 20px;
  border-radius: 10px;
  border: 1px solid #d4af37;
  margin-top: 25px;
  height: 200px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.9rem;
}

.log-success { color: #00ff00; }
.log-error { color: #ff4444; }
.log-warning { color: #ffa500; }
.log-info { color: #d4af37; }

/* Auditoria */
.audit-card {
  background: #1a1f1a;
  padding: 25px;
  border-radius: 15px;
  border: 1px solid rgba(212,175,55,0.3);
  margin-bottom: 20px;
}

.progress-bar {
  width: 100%;
  height: 15px;
  border-radius: 10px;
  background: #222;
  margin-top: 15px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  width: 0%;
  transition: 0.25s;
  background: linear-gradient(90deg, #2a9fd6, #4CAF50, #d4af37);
}

.valid { color: #4CAF50; }
.invalid { color: #ff5c5c; }
.audit-item {
  background: #1a1a1a;
  padding: 15px;
  border-radius: 10px;
  margin-top: 12px;
}
</style>
</head>
<body>

<h1>üéõÔ∏è Painel Completo ‚Äî Terra Dourada</h1>
<div class="subtitle">Sincroniza√ß√£o, Auditoria e Controle Total da Urna</div>

<!-- Abas -->
<div class="tabs">
  <button class="tab-btn active" onclick="abrirTab('dashboard')">üìä Dashboard</button>
  <button class="tab-btn" onclick="abrirTab('auditoria-local')">üõ°Ô∏è Auditoria Local</button>
  <button class="tab-btn" onclick="abrirTab('auditoria-ipfs')">üåê Auditoria IPFS</button>
</div>

<!-- Tab: Dashboard -->
<div id="dashboard" class="tab-content active">
  <div class="controls">
    <button onclick="atualizarDashboard()">üìä Atualizar Dashboard</button>
    <button onclick="reenviarPendentes()">üîÑ Sincronizar Pendentes</button>
    <button onclick="exportarDados()">üíæ Exportar Dados</button>
    <button onclick="limparEnviados()">üóëÔ∏è Limpar Enviados</button>
  </div>

  <div class="dashboard">
    <div class="stat-card">
      <div class="stat-label">Votos Pendentes</div>
      <div class="stat-number stat-pendente" id="count-pendentes">0</div>
      <div class="stat-label">Aguardando Sincroniza√ß√£o</div>
    </div>
    
    <div class="stat-card">
      <div class="stat-label">Votos Enviados</div>
      <div class="stat-number stat-enviado" id="count-enviados">0</div>
      <div class="stat-label">Processados com Sucesso</div>
    </div>
  </div>

  <div class="votos-container">
    <div class="votos-list">
      <h3>üìã Votos Pendentes</h3>
      <div id="lista-pendentes">
        <div class="empty-state">
          <i>üì≠</i>
          Nenhum voto pendente
        </div>
      </div>
    </div>
    
    <div class="votos-list">
      <h3>üì¶ Votos Enviados</h3>
      <div id="lista-enviados">
        <div class="empty-state">
          <i>üì¨</i>
          Nenhum voto enviado
        </div>
      </div>
    </div>
  </div>

  <div id="log"></div>
</div>

<!-- Tab: Auditoria Local -->
<div id="auditoria-local" class="tab-content">
  <div class="audit-card">
    <h2 id="statusTextLocal">Clique para iniciar a auditoria local</h2>

    <div class="progress-bar">
      <div id="progressFillLocal" class="progress-fill"></div>
    </div>

    <div id="resultadoLocal"></div>

    <div class="controls">
      <button onclick="auditarVotos()">üîç Iniciar Auditoria Local</button>
      <button onclick="exportarTXT()">üìÑ Exportar LOG (.txt)</button>
      <button onclick="exportarPDF()">üßæ Exportar PDF Completo</button>
    </div>
  </div>
</div>

<!-- Tab: Auditoria IPFS -->
<div id="auditoria-ipfs" class="tab-content">
  <div class="audit-card">
    <h2>üåê Auditoria Sovereign - Verifica√ß√£o IPFS</h2>
    <p>Audita votos diretamente do PouchDB local e compara com o pacote real salvo no IPFS.</p>

    <div class="controls">
      <button onclick="auditarIPFS(10)">Auditar 10 votos</button>
      <button onclick="auditarIPFS(50)">Auditar 50 votos</button>
      <button onclick="auditarIPFS(100)">Auditar 100 votos</button>
    </div>

    <div id="logBoxIPFS" class="votos-list" style="margin-top: 20px; height: 300px;"></div>
  </div>
</div>

<audio id="scanSound" src="scan.mp3"></audio>

<script>
// ==============================
// CONFIGURA√á√ïES GLOBAIS
// ==============================
const dbVotos = new PouchDB('terra_dourada_votos_local');
const dbAutorizacoes = new PouchDB('terra_dourada_autorizacoes');
const IPFS_GATEWAY = "https://ipfs.io/ipfs/";
let LOGS = [];

// Hashes dos candidatos para auditoria local
const candidatosHashes = {
  candidato_1: "099e7cc1f12662a33d1d757780b20a8bffe7a6c12651b585d34ac49ddbcab307",
  candidato_2: "1c3c978eae25037d6e7383b9f9b51b84a20dc2bdb0551434c1a5388d97f1c065",
  branco: "hash_voto_branco_123456789"
};

// ==============================
// FUN√á√ïES AUXILIARES - CORRIGIDAS
// ==============================
async function getEleitorInfo(doc) {
  try {
    // Se j√° tem um nome real (n√£o √© um CID), retorna direto
    if (doc.eleitor && !doc.eleitor.startsWith('cid_') && doc.eleitor !== 'token_autorizacao') {
      return doc.eleitor;
    }
    
    // Busca na autoriza√ß√£o usando o CID como token
    if (doc.eleitor && doc.eleitor.startsWith('cid_')) {
      const autorizacoes = await dbAutorizacoes.allDocs({ include_docs: true });
      const autorizacao = autorizacoes.rows.find(row => 
        row.doc._id === doc.eleitor || 
        row.doc.codigo === doc.eleitor ||
        (row.doc.dadosEleitor && row.doc.dadosEleitor.identificacao === doc.eleitor)
      );
      
      if (autorizacao && autorizacao.doc.dadosEleitor && autorizacao.doc.dadosEleitor.nome) {
        return autorizacao.doc.dadosEleitor.nome;
      }
    }
    
    // Se n√£o encontrou, retorna o CID formatado
    return `Eleitor (${doc.eleitor || 'N√£o identificado'})`;
  } catch (err) {
    return `Erro: ${doc.eleitor || 'Sem dados'}`;
  }
}

function getCandidatoInfo(doc) {
  // Usa o nome real do candidato que est√° salvo no voto
  return doc.candidato_nome || doc.candidato_id || 'Candidato n√£o identificado';
}

function getNomeCandidato(codigo) {
  // Remove qualquer mapeamento - usa o nome real
  return codigo || 'Voto sem candidato';
}

function getEmojiCandidato(codigo) {
  // Emojis baseados no nome real do candidato
  if (codigo.includes('Jo√£o') || codigo.includes('joao')) return 'üü¶';
  if (codigo.includes('Paulo') || codigo.includes('paulo')) return 'üü©';
  if (codigo.includes('Maria') || codigo.includes('maria')) return 'üü•';
  if (codigo.includes('Carlos') || codigo.includes('carlos')) return 'üü®';
  if (codigo.includes('BRANCO')) return '‚ö™';
  return '‚ö™';
}

function getCIDInfo(doc) {
  return doc.cid_pinata || doc.cid || 'Aguardando CID';
}

function getTimestampInfo(doc) {
  return doc.timestamp || doc.dataCriacao || Date.now();
}

// ==============================
// FUN√á√ïES DE ABA
// ==============================
function abrirTab(tabName) {
  // Esconde todas as tabs
  document.querySelectorAll('.tab-content').forEach(tab => {
    tab.classList.remove('active');
  });
  
  // Remove active de todos os bot√µes
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  // Mostra a tab selecionada
  document.getElementById(tabName).classList.add('active');
  event.target.classList.add('active');
}

// ==============================
// DASHBOARD PRINCIPAL - CORRIGIDO
// ==============================
async function atualizarDashboard() {
  try {
    const allVotos = await dbVotos.allDocs({ include_docs: true });
    
    // Processa votos e busca nomes reais dos eleitores
    const votosComInfo = await Promise.all(
      allVotos.rows.map(async (row) => {
        const voto = row.doc;
        const eleitorNome = await getEleitorInfo(voto);
        return {
          ...voto,
          eleitorCompleto: eleitorNome
        };
      })
    );
    
    const pendentes = votosComInfo.filter(doc => doc.erro === "sem_conexao_backend");
    const enviados = votosComInfo.filter(doc => doc.cid_pinata && !doc.erro);
    
    // Atualiza contadores
    document.getElementById('count-pendentes').textContent = pendentes.length;
    document.getElementById('count-enviados').textContent = enviados.length;
    
    // Atualiza lista de pendentes
    const listaPendentes = document.getElementById('lista-pendentes');
    if (pendentes.length === 0) {
      listaPendentes.innerHTML = `
        <div class="empty-state">
          <i>üì≠</i>
          Nenhum voto pendente
        </div>
      `;
    } else {
      listaPendentes.innerHTML = pendentes.map((doc, index) => {
        const candidato = getCandidatoInfo(doc);
        
        return `
        <div class="voto-item voto-pendente">
          <div class="voto-candidato">${getEmojiCandidato(candidato)} ${getNomeCandidato(candidato)}</div>
          <div class="voto-eleitor">Eleitor: ${doc.eleitorCompleto}</div>
          <div class="voto-timestamp">${new Date(getTimestampInfo(doc)).toLocaleString()}</div>
        </div>
        `;
      }).join('');
    }
    
    // Atualiza lista de enviados
    const listaEnviados = document.getElementById('lista-enviados');
    if (enviados.length === 0) {
      listaEnviados.innerHTML = `
        <div class="empty-state">
          <i>üì¨</i>
          Nenhum voto enviado
        </div>
      `;
    } else {
      listaEnviados.innerHTML = enviados.map((doc, index) => {
        const candidato = getCandidatoInfo(doc);
        const cid = getCIDInfo(doc);
        
        return `
        <div class="voto-item voto-enviado">
          <div class="voto-candidato">${getEmojiCandidato(candidato)} ${getNomeCandidato(candidato)}</div>
          <div class="voto-eleitor">Eleitor: ${doc.eleitorCompleto}</div>
          <div class="voto-cid">CID: ${cid}</div>
          <div class="voto-timestamp">${new Date(getTimestampInfo(doc)).toLocaleString()}</div>
        </div>
        `;
      }).join('');
    }
    
    log('Dashboard atualizado com sucesso', 'success');
    
  } catch (err) {
    log(`Erro ao atualizar dashboard: ${err.message}`, 'error');
  }
}

// ==============================
// SINCRONIZAR PENDENTES - CORRIGIDO
// ==============================
async function reenviarPendentes() {
  try {
    const all = await dbVotos.allDocs({ include_docs: true });
    const pendentes = all.rows.map(r => r.doc).filter(doc => doc.erro === "sem_conexao_backend");
    
    if (pendentes.length === 0) {
      log('Nenhum voto pendente para sincronizar', 'warning');
      return;
    }

    log(`Iniciando sincroniza√ß√£o de ${pendentes.length} votos...`, 'info');

    let sucessos = 0;
    let erros = 0;

    for (let doc of pendentes) {
      try {
        const eleitor = await getEleitorInfo(doc);
        const candidato = getCandidatoInfo(doc);
        
        const payload = {
          nome_produtor: eleitor,
          produto: candidato,
          screenshot_hash: doc.screenshot_hash || "hash_nao_disponivel",
          tipo: "voto_presidencial"
        };

        const res = await fetch("http://127.0.0.1:8080/mel", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const data = await res.json();
        
        if (res.ok) {
          const cid = data.IpfsHash || data.cid || data.hash || "CID n√£o retornado";
          
          // Atualiza o documento
          doc.cid_pinata = cid;
          doc.resposta_backend = data;
          delete doc.erro;
          await dbVotos.put(doc);
          
          log(`‚úÖ ${getNomeCandidato(candidato)} sincronizado ‚Üí ${cid.substring(0, 20)}...`, 'success');
          sucessos++;
        } else {
          log(`‚ùå ${getNomeCandidato(candidato)} ‚Üí Erro: ${data.message || res.status}`, 'error');
          erros++;
        }

      } catch (err) {
        log(`‚ùå Falha: ${getNomeCandidato(getCandidatoInfo(doc))} - ${err.message}`, 'error');
        erros++;
      }
    }

    log(`Sincroniza√ß√£o conclu√≠da: ${sucessos} sucessos, ${erros} erros`, 
        erros === 0 ? 'success' : 'warning');
    
    // Atualiza o dashboard ap√≥s sincroniza√ß√£o
    setTimeout(atualizarDashboard, 500);
    
  } catch (err) {
    log(`Erro geral na sincroniza√ß√£o: ${err.message}`, 'error');
  }
}

// ==============================
// EXPORTAR DADOS - CORRIGIDO
// ==============================
async function exportarDados() {
  const all = await dbVotos.allDocs({ include_docs: true });
  
  const dadosExportar = await Promise.all(
    all.rows.map(async (row) => {
      const doc = row.doc;
      const eleitor = await getEleitorInfo(doc);
      const candidato = getCandidatoInfo(doc);
      
      return {
        nome_produtor: eleitor,
        produto: candidato,
        nome_candidato: getNomeCandidato(candidato),
        screenshot_hash: doc.screenshot_hash || "N/A",
        tipo: "voto_presidencial",
        timestamp: getTimestampInfo(doc),
        status: doc.erro ? "pendente" : "enviado",
        cid: getCIDInfo(doc)
      };
    })
  );
  
  const blob = new Blob([JSON.stringify(dadosExportar, null, 2)], {
    type: 'application/json'
  });
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'votos_terra_dourada_local.json';
  a.click();
  
  log(`Dados exportados: ${dadosExportar.length} votos`, 'success');
}

// ==============================
// LIMPAR ENVIADOS
// ==============================
async function limparEnviados() {
  if (!confirm('Tem certeza que deseja limpar os votos j√° enviados?')) return;
  
  const all = await dbVotos.allDocs({ include_docs: true });
  const enviados = all.rows.map(r => r.doc).filter(doc => doc.cid_pinata && !doc.erro);
  
  for (let doc of enviados) {
    await dbVotos.remove(doc);
  }
  
  log(`${enviados.length} votos enviados foram removidos`, 'warning');
  setTimeout(atualizarDashboard, 500);
}

// ==============================
// AUDITORIA LOCAL - CORRIGIDA
// ==============================
async function auditarVotos() {
  LOGS = []; // limpa log
  const t0 = performance.now();

  const btn = document.querySelector('#auditoria-local .controls button');
  btn.disabled = true;
  btn.innerHTML = "‚è≥ Auditando...";

  document.getElementById("scanSound").play().catch(()=>{});

  document.getElementById("statusTextLocal").innerText = "Auditando votos...";

  const progress = document.getElementById("progressFillLocal");
  progress.style.width = "0%";

  const resultHTML = [];
  let auditoriaCompleta = true;
  let totalVotos = 0;
  let validos = 0;

  const result = await dbVotos.allDocs({ include_docs: true });
  const docs = result.rows;

  const total = docs.length;

  for (let i = 0; i < total; i++) {
    const row = docs[i].doc;

    progress.style.width = ((i / total) * 100).toFixed(1) + "%";

    if (!row.screenshot_hash || !row.candidato_id) continue;

    totalVotos++;

    const candidatoId = row.candidato_id;
    const hash = row.screenshot_hash;
    const eleitorNome = await getEleitorInfo(row);

    if (candidatosHashes[candidatoId] === hash) {
      validos++;
      resultHTML.push(`
        <div class="audit-item valid">
          <b>Voto v√°lido ‚úî</b><br>
          Candidato: ${getNomeCandidato(getCandidatoInfo(row))}<br>
          Eleitor: ${eleitorNome}<br>
          Hash: ${hash.substring(0,25)}...
        </div>
      `);

      LOGS.push(`‚úî OK | ${getNomeCandidato(getCandidatoInfo(row))} | ${eleitorNome} | ${hash}`);
    } else {
      auditoriaCompleta = false;
      resultHTML.push(`
        <div class="audit-item invalid">
          <b>INV√ÅLIDO ‚ùå</b><br>
          Candidato: ${getNomeCandidato(getCandidatoInfo(row))}<br>
          Eleitor: ${eleitorNome}<br>
          Encontrado: ${hash.substring(0,25)}...<br>
          Esperado: ${candidatosHashes[candidatoId] ? candidatosHashes[candidatoId].substring(0,25) : 'Hash n√£o cadastrado'}...
        </div>
      `);
      LOGS.push(`‚ùå ERRO | ${getNomeCandidato(getCandidatoInfo(row))} | ${eleitorNome} | hash mismatch`);
    }
  }

  progress.style.width = "100%";

  const t1 = performance.now();
  const tempoTotal = ((t1 - t0) / 1000).toFixed(2);

  // RESUMO FINAL
  let resumo = "";
  if (auditoriaCompleta) {
    resumo = `<h2 class="valid">Todos os ${totalVotos} votos est√£o √≠ntegros ‚úî</h2>`;
  } else {
    resumo = `<h2 class="invalid">${validos} de ${totalVotos} votos √≠ntegros</h2>`;
  }

  resumo += `<p>‚è± Tempo total: ${tempoTotal}s</p>`;
  LOGS.push("Tempo total: " + tempoTotal + "s");

  document.getElementById("resultadoLocal").innerHTML = resultHTML.join("") + resumo;

  btn.disabled = false;
  btn.innerHTML = "üîç Reauditar";

  document.getElementById("statusTextLocal").innerText = "Auditoria conclu√≠da";
}

// ==============================
// AUDITORIA IPFS - CORRIGIDA COM ESTRUTURA REAL
// ==============================
async function auditarIPFS(qtd) {
  const logBox = document.getElementById("logBoxIPFS");
  logBox.innerHTML = "";
  
  logIPFS("üîç Carregando votos locais do PouchDB...");

  const all = await dbVotos.allDocs({ include_docs: true });
  const docs = all.rows.slice(0, qtd).map(r => r.doc);

  logIPFS(`üì¶ Total carregado: ${docs.length} votos.`);

  let okCount = 0;
  let failCount = 0;

  for (let doc of docs) {
    try {
      const cid = doc.cid_pinata;
      const eleitorNome = await getEleitorInfo(doc);
      const candidatoLocal = getCandidatoInfo(doc);
      
      if (!cid) {
        logIPFS(`‚ùå CID ausente - ${eleitorNome} - ${getNomeCandidato(candidatoLocal)}`, "bad");
        failCount++;
        continue;
      }

      logIPFS(`üåê Buscando pacote IPFS: ${cid.substring(0, 20)}...`);

      const ipfsData = await fetchIPFSPackage(cid);

      // ‚úÖ ESTRUTURA REAL DA PINATA - CORRIGIDA
      // A Pinata salva exatamente o payload que enviamos
      const ipfsProduto = ipfsData.produto || ipfsData.candidate || null;
      const ipfsNomeProdutor = ipfsData.nome_produtor || null;
      const ipfsScreenshotHash = ipfsData.screenshot_hash || null;

      if (!ipfsProduto) {
        logIPFS(`‚ùå Pacote IPFS inv√°lido (sem produto/candidato): ${cid}`, "bad");
        failCount++;
        continue;
      }

      // ‚úÖ COMPARA√á√ÉO CORRETA - Local vs IPFS
      const divergencias = [];
      
      // 1. Comparar candidato
      if (candidatoLocal !== ipfsProduto) {
        divergencias.push(`CANDIDATO: Local "${candidatoLocal}" ‚â† IPFS "${ipfsProduto}"`);
      }

      // 2. Comparar eleitor (se dispon√≠vel no IPFS)
      if (ipfsNomeProdutor && eleitorNome !== ipfsNomeProdutor) {
        divergencias.push(`ELEITOR: Local "${eleitorNome}" ‚â† IPFS "${ipfsNomeProdutor}"`);
      }

      // 3. Comparar hash da screenshot
      if (doc.screenshot_hash && ipfsScreenshotHash && doc.screenshot_hash !== ipfsScreenshotHash) {
        divergencias.push(`HASH: Local "${doc.screenshot_hash.substring(0, 20)}..." ‚â† IPFS "${ipfsScreenshotHash.substring(0, 20)}..."`);
      }

      if (divergencias.length > 0) {
        logIPFS(`‚ùå Diverg√™ncias detectadas (${eleitorNome}):\n${divergencias.join('\n')}`, "bad");
        failCount++;
        continue;
      }

      // ‚úÖ Verificar proof_bytes (se existir)
      if (ipfsData.proof_bytes) {
        logIPFS(`‚úî Voto OK | ${getNomeCandidato(candidatoLocal)} | ${eleitorNome} | Prova OK | CID: ${cid.substring(0, 20)}...`, "good");
      } else {
        logIPFS(`‚úî Voto OK | ${getNomeCandidato(candidatoLocal)} | ${eleitorNome} | CID: ${cid.substring(0, 20)}...`, "good");
      }
      okCount++;

    } catch (err) {
      const eleitorNome = await getEleitorInfo(doc);
      logIPFS(`‚ùå Erro ao auditar voto (${eleitorNome}): ${err.message}`, "bad");
      failCount++;
    }
  }

  logIPFS("----------------------------------------------");
  logIPFS(`üü¢ CONSISTENTES: ${okCount}`, "good");
  logIPFS(`üî¥ INCONSISTENTES: ${failCount}`, "bad");
  logIPFS(`üìä TOTAL AUDITADO: ${docs.length} votos`, "info");
  logIPFS("----------------------------------------------");
}

async function fetchIPFSPackage(cid) {
  const url = IPFS_GATEWAY + cid;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`IPFS ${res.status}: ${await res.text()}`);
  return res.json();
}

function logIPFS(msg, type = null) {
  const box = document.getElementById("logBoxIPFS");
  const css = type === "good" ? "valid" :
              type === "bad" ? "invalid" :
              "info";
  box.innerHTML += `<div class="${css}">${msg}</div>`;
  box.scrollTop = box.scrollHeight;
}

// ==============================
// EXPORTA√á√ïES
// ==============================
function exportarTXT() {
  const blob = new Blob([LOGS.join("\n")], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "auditoria_terra_dourada.txt";
  a.click();
}

async function exportarPDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit: 'mm', format: 'a4' });

  pdf.setFontSize(18);
  pdf.text("Terra Dourada - Auditoria Completa", 10, 15);

  pdf.setFontSize(12);

  let y = 25;
  LOGS.forEach(l => {
    pdf.text(l, 10, y);
    y += 7;
  });

  pdf.save("auditoria_terra_dourada.pdf");
}

// ==============================
// LOG GLOBAL
// ==============================
function log(msg, tipo = 'info') {
  const box = document.getElementById("log");
  const timestamp = new Date().toLocaleTimeString();
  box.innerHTML += `<span class="log-${tipo}">[${timestamp}] ${msg}</span>\n`;
  box.scrollTop = box.scrollHeight;
}

// ==============================
// INICIALIZA√á√ÉO
// ==============================
atualizarDashboard();
</script>

</body>
</html>
